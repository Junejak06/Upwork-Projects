# -*- coding: utf-8 -*-
"""generateL1_v20_why_apply.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nxTRXw_-YRStWxFRaZ3a1yhpk3hWIyds
"""

#!pip install PyPDF2 openai langchain docx python-docx pandas

import os,sys,re
import PyPDF2
import openai
import json
from docx import Document
from docx.shared import Pt, RGBColor
from docx.enum.text import WD_PARAGRAPH_ALIGNMENT
from docx.oxml import OxmlElement
from langchain.output_parsers import ResponseSchema, StructuredOutputParser
from langchain.prompts import ChatPromptTemplate
from langchain.prompts.chat import SystemMessage, HumanMessagePromptTemplate
from langchain.chat_models import ChatOpenAI
import pandas as pd
from PyPDF2 import PdfReader
from docx import Document
import docx2txt
new_filename = "input_jd.pdf"
client_id=None
# Set your OpenAI GPT-3 API key here
api_key = "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"
client_names = None


def read_client_names():
    with open('client_names.txt', 'r') as file:
        return file.read()

def ms_checkfile_exist(filename):
    # Check if the file exists
    if os.path.exists(filename):
        # Copying the content of the specified file to "input_jd.pdf"
        with open(filename, 'rb') as original_file:
            content = original_file.read()
            with open(new_filename, 'wb') as new_file:
                new_file.write(content)
        print(f"{filename} has been copied to {new_filename}")
    else:
        print(f"Error: {filename} does not exist!")
        sys.exit("terminating program.")


def read_text_from_file(file_path):
    text = ""
    # print(file_path)
    if file_path.endswith(('.doc', '.docx')):
        document = docx2txt.process(file_path)
        # print(document)
        # for paragraph in document.paragraphs:
        #     text += paragraph.text + "\n"
        #     print(text)
        text += document + "\n"
    elif file_path.endswith('.pdf'):
        text = read_pdf(file_path)
        # reader = PdfReader(file_path)    
        # for page in range(len(reader.pages)):
        #     text += reader.pages[page].extract_text()
    else:
        print("Error: File format not supported")
    return text

def append_why_apply(client_id, position_type):
    # Read the excel file and convert it to a dataframe
    database = pd.read_excel("Why App Data.xlsx")
    print(client_id, position_type)
    # Extract the first word from the position_type and convert to lowercase
    position_first_word = position_type.split()[0].lower()

    # Filter the dataframe based on the client_id and the first word of the position_type
    d = database[
        (database["Index"] == client_id) &
        (database["Position Type"].str.split().str[0].str.lower().str.contains(position_first_word))
    ]
    print(d)
    # Check if any rows were found
    if len(d) == 0:
        return "No matching data found for the provided client_id and position_type."

    # Return the 'Why Apply' value from the filtered row
    return d["Why apply?"].iloc[0]

def add_text_with_formatting(doc, label, value, bold=False):
    paragraph = doc.add_paragraph()

    # Add label with formatting
    label_run = paragraph.add_run(label)
    label_font = label_run.font
    label_font.name = 'Arial'
    label_font.size = Pt(11)
    label_font.color.rgb = RGBColor(0, 0, 0)  # Black color

    if bold:
        label_run.bold = True

    # Add value with formatting
    value_run = paragraph.add_run(value)
    value_font = value_run.font
    value_font.name = 'Arial'
    value_font.size = Pt(11)
    value_font.color.rgb = RGBColor(0, 0, 0)  # Black color


def create_docx_L1(formatted_title, part1, part2, part3, filename_output="output.docx"):
    # Create a new Word document
    doc = Document()
    data = part1 #part 1
    why_apply = append_why_apply(client_id,data["Type"])
    #add main heading
    # doc.add_heading(formatted_title, 0)
    add_text_with_formatting(doc, formatted_title, "", bold=True)
    doc.add_paragraph("")
    # doc.add_paragraph("")

    #add heading
    # doc.add_heading('Job Description', 1)
    # Add content from the dictionary to the document
    # doc.add_paragraph("Start Date: " + data["Start Date"])
    add_text_with_formatting(doc, "Start Date: ", data["Start Date"], bold=True)
    add_text_with_formatting(doc, "Type: ", data["Type"], bold=True)
    
    
    # doc.add_paragraph("Type: " + data["Type"])
    if not any(term in data["Type"].lower() for term in ["full time", "fulltime", "full-time"]):
        add_text_with_formatting(doc, "Estimated Duration: ", data["Estimated Duration"], bold=True)
      # doc.add_paragraph("Estimated Duration: " + data["Estimated Duration"])
    # doc.add_paragraph("Work Setting: " + data["Work Setting"])
    add_text_with_formatting(doc, "Work Setting: ", data["Work Setting"], bold=True)

    doc.add_paragraph("")


    # part 2

    #add heading
    add_text_with_formatting(doc, "Job Requirements", "", bold=True)
    # doc.add_paragraph("")
    # doc.add_heading('Job Requirements', 1)

    data = part2['Requirements']
    # list of strings
    for item in data:
        paragraph = doc.add_paragraph(item)

        # Set font properties for each paragraph
        run = paragraph.runs[0]
        font = run.font
        font.name = 'Arial'  # Set font to Arial
        font.size = Pt(11)   # Set font size to 11
        font.color.rgb = RGBColor(0, 0, 0)  # Set color to black

    # part 3

    #add heading
    doc.add_paragraph("")
    add_text_with_formatting(doc, "Job Responsibilities", "", bold=True)
    # doc.add_paragraph("")
    # doc.add_heading('Job Responsibilities', 1)
    data = part3['Responsibilities']
    # list of strings
    for item in data:
        paragraph = doc.add_paragraph(item)

        # Set font properties for each paragraph
        run = paragraph.runs[0]
        font = run.font
        font.name = 'Arial'  # Set font to Arial
        font.size = Pt(11)   # Set font size to 11
        font.color.rgb = RGBColor(0, 0, 0)  # Set color to black

    # part 4 why apply
    # doc.add_heading('Why Apply?', 1)

    if "No matching" in why_apply:
        pass
    else:
        doc.add_paragraph("")
        add_text_with_formatting(doc, "Why Apply?", "", bold=True)
        # doc.add_paragraph("")

        paragraph = doc.add_paragraph(why_apply)

            # Set font properties for each paragraph
        run = paragraph.runs[0]
        font = run.font
        font.name = 'Arial'  # Set font to Arial
        font.size = Pt(11)   # Set font size to 11
        font.color.rgb = RGBColor(0, 0, 0)  # Set color to black
        # doc.add_paragraph(why_apply)
    # Save the document
    doc.save(filename_output)
    return formatted_title, filename_output

def clean_text(text):
    # Remove emails
    text = re.sub(r'\S+@\S+', '', text)

    # Remove phone numbers (various formats)
    text = re.sub(r'\(?\+?[0-9]*\)?-?[0-9]+-?[0-9]+-?[0-9]+', '', text)

    # Remove characters that repeat more than 10 times
    text = re.sub(r'(.)\1{10,}', '', text)

    # Remove multiple whitespaces
    text = re.sub(r'\s+', ' ', text).strip()

    return text
llm_model = "gpt-4"
def read_pdf(file_path, max_tokens=17000):
    with open(file_path, 'rb') as pdf_file:
        pdf_reader = PyPDF2.PdfReader(pdf_file)
        relevant_text = []

        num_pages = len(pdf_reader.pages)

        if num_pages < 3:
            print("small pdf")
            for page_num in range(num_pages):
                page_text = pdf_reader.pages[page_num].extract_text().lower()
                cleaned_page_text = page_text
                relevant_text.append(cleaned_page_text)
        else:
            print("big pdf")
            llm_model = "gpt-4"
            page_text = pdf_reader.pages[0].extract_text().lower()
            for page_num in range(num_pages):
                page_text = pdf_reader.pages[page_num].extract_text().lower()
                cleaned_page_text = clean_text(page_text)
                relevant_text.append(cleaned_page_text)

            if not relevant_text:
                print("No relevant page found, including as much content as possible.")
                all_text = " ".join([pdf_reader.pages[i].extract_text().lower() for i in range(num_pages)])
                cleaned_text = clean_text(all_text)
                relevant_text.append(cleaned_text)

    return str(" ".join(relevant_text))[:max_tokens]

def process_jd_l1(filename, filename_output="output.docx", clientid=None):
    global client_names, client_id
    client_id = clientid
    # ms_checkfile_exist(filename)

    # jd_document = read_pdf(new_filename)
    jd_document = read_text_from_file(filename)
    client_names = read_client_names()
    llm_model = "gpt-4"
    part1_defaults = {
        "Start Date": "ASAP",
    }

    # Part 1
    type_description = """
    Determine the type of employment as:
    - 'Temporary Project' if contract duration (in terms of number of hours or months) is mentioned and if the JD does not mention conversion to full-time OR if the type is not specified.
    - 'Full-time direct employment with V Staffing Client' if salary is mentioned in dollar terms. Note: Ensure the full phrase is used.
    - 'Temp-to-Hire' if salary amount and contract duration (number of hours or months) both are explicitly mentioned, OR if the JD mentions conversion to direct/full-time employment.
    """
    type_schema = ResponseSchema(name="Type", description=type_description)

    estimated_duration_description = """
    For 'Temporary Project', the estimated duration should be:
    - '[# of months] months with possible extensions' or
    - '12 months with possible extensions' as the default value if contract duration is not specified.

    For 'Temp-to-Hire', the estimated duration should be:
    - '[number of months] months with possible conversion to direct employment with V Staffing client' or
    - '3 months with possible extensions' if the contract duration is not specified.

    Note:
    - Convert contract durations from hours to months, e.g., 1040 hours = 6 months, 2080 hours = 12 months.
    - Convert specific date ranges to number of months, e.g., 02/14/2022 - 06/30/2022 = 4 months.
    """

    estimated_duration_schema = ResponseSchema(name="Estimated Duration", description=estimated_duration_description)

    
    work_setting_description = """
    Determine the Work setting as:
    - '100% onsite' if the Job Description explicitly mentions that the position is onsite
    - '100% remote' if the position is mentioned as fully remote
    - 'Hybrid' if such details are available. Mention those details briefly as well.
    - If none of the above information is available in the Job description, default value for work setting is 'Telework may be approved at the discretion of the Contract Manager'.
    
    """


    work_setting_schema = ResponseSchema(name="Work Setting", description=work_setting_description)

    response_schemas_part1 = [type_schema, estimated_duration_schema, work_setting_schema]
    output_parser_part1 = StructuredOutputParser.from_response_schemas(response_schemas_part1)
    format_instructions_part1 = output_parser_part1.get_format_instructions()

    #Part 3
    format_instructions_part3 = ResponseSchema(name="Responsibilities",
                                            description="Extract and List the top responsibilities (limit to 7), avoid generic points. Each extracted responsibility should be numbered. (this is a Python List object)")
    output_parser_part3 = StructuredOutputParser.from_response_schemas([format_instructions_part3])
    format_instructions_part3 = output_parser_part3.get_format_instructions()

    # SECTION 1
    candidate_responsabilities_p_template = ChatPromptTemplate.from_template(
        """
        As a hiring agency, your task is to analyze the provided job description thoroughly. Your objective is to extract crucial details regarding the nature of the job.
        Ensure not to focus on the responsibilities or skills but to hone in on the overarching attributes of the position. The job description will be delimited by ```. Follow all the rules strictly.

        Extract the following:
        - Type : {type_description}
        - Estimated Duration : {estimated_duration_description}
        - Work Setting : {work_setting_description}

        Job description:
        ```{jd_document}```
        """
    )

    candidate_responsabilities = candidate_responsabilities_p_template.format_messages(jd_document=jd_document,type_description=type_description,estimated_duration_description=estimated_duration_description, work_setting_description=work_setting_description, format_instructions=format_instructions_part1)
    print(llm_model)
    chat = ChatOpenAI(temperature=0.0, model=llm_model, openai_api_key=api_key)
    part1_raw_v1 = chat(candidate_responsabilities)



    candidate_responsabilities_p2_template = ChatPromptTemplate.from_template(
        """
        Based on the Job Description, make sure the extraction was done accurately for the following:
        - Type : {type_description}
        - Estimated Duration : {estimated_duration_description}
        - Work Setting : {work_setting_description}

        Job description:
        ```{jd_document}```

        Original Extraction:
        {extracted_data}

        I want you to correct/improve the extracted data making sure all my guidelines are strictly adhered to, and return it as the JSON format :
        ----------------------------
        {format_instructions}
        ----------------------------
        return a valid JSON object
        """
    )

    candidate_responsabilities = candidate_responsabilities_p2_template.format_messages(jd_document=jd_document,type_description=type_description,estimated_duration_description=estimated_duration_description, work_setting_description=work_setting_description, extracted_data = part1_raw_v1.content, format_instructions=format_instructions_part1)

    part1_raw_v2 = chat(candidate_responsabilities)



    print("~~~~~~~~~PART 1~~~~~~~~~~~\n")
    print(part1_raw_v2.content)
    print("\n~~~~~~~~~~~~~~~~~~~~~~~~~~")



    # Schema Definition for Job Role, Type, and Location
    job_role_description = "Extract the position or job title from the JD. if not mentionned use your best guess."
    job_role_schema = ResponseSchema(name="Job Role", description=job_role_description)

    job_type_description = "Determine if the job is 'onsite', 'remote', or 'hybrid'."
    job_type_schema = ResponseSchema(name="Job Type", description=job_type_description)

    job_location_description = "Extract the job location in the format 'City, State'. omit if not mentionned"
    job_location_schema = ResponseSchema(name="Job Location", description=job_location_description)

    output_parser_part0_subject = StructuredOutputParser.from_response_schemas([job_type_schema, job_role_schema, job_location_schema])
    format_instructions_part0_subject = output_parser_part0_subject.get_format_instructions()

    # Chat Prompt Template
    job_details_template = ChatPromptTemplate.from_template(
        """
        Based on the provided job description extract the following:
        - Job Role : {job_role_description}
        - Job Type : {job_type_description}
        - Job Location : {job_location_description}

        overview:
        {part1_raw}

        Job description:
        ```{jd_document}```

        ----------------------------
        {format_instructions}
        ----------------------------
        return a valid JSON object
        """
    )

    # Extracting the Required Information
    chat_prompt = job_details_template.format_messages(
        jd_document=jd_document,
        job_role_description=job_role_description,
        job_type_description=job_type_description,
        job_location_description=job_location_description,
        part1_raw=part1_raw_v2.content,
        format_instructions=job_location_schema
    )

    
    #Commented for testing

    job_details_response = chat(chat_prompt) 


    part0_subject = output_parser_part0_subject.parse(job_details_response.content)

    formatted_title = f"{part0_subject['Job Role']} ({part0_subject['Job Type']}) – {part0_subject['Job Location']}"

    #Part 2
    format_instructions_part2 = ResponseSchema(name="Requirements",
                                        description="Extract and List the technology/skills related requirements for the job. Make sure to specify the duration if mentioned (e.g., '2+ years'). If it's a preferred skill, mark it as '(preferred)'. Exclude soft skills. Remove repeated skills. Each extracted requirement should be numbered. (this is a Python List object)")

    output_parser_part2 = StructuredOutputParser.from_response_schemas([format_instructions_part2])
    format_instructions_part2 = output_parser_part2.get_format_instructions()


    # SECTION 2

    candidate_skillset_p_template = ChatPromptTemplate.from_template(
        """
        As a hiring agency, your objective is to analyze the job description and extract essential technical skills, certifications, and educational qualifications necessary for the role. Please adhere to the following guidelines during extraction:

        1. Requirements should be technology or skill-related (look for content matching: 'experience', 'ability', 'understanding', 'skill', 'technology').
        2. Each requirement should be rephrased in the following format:
        Generic format: "Experience with/in/working as [skill/technology] ('experience duration' or 'preferred' or nothing)"
    - As a default do not write anything in brackets
    - Mention duration of minimum required experience if mentioned in the job description. If it is mentioned as a range with lower limit as 0 years, mention only the upper limit. Example if the job description mentions the required experience duration as '0-2 years', please mention '2 years' in brackes.
    - Write 'preferred' in brackets for good-to-have or preferred skills, as mentioned in the job description

        - Example 1: Experience with [skill/technology] (3+ years) Add duration of required experience if mentioned in the job description
        - Example 2: Experience with Microsoft Graph API, Azure DevOps Pipeline, ESRI JavaScript API, OpenText eDocs API, Google API (preferred).

        3. If the Work setting is:
          a. 100% onsite: the first requirement should indicate the location requirement as "Availability to work 100% of the time at the Client’s site ([in City, State] if available in the job description)". 
          b. 100% Remote: do not mention anything 
          c. Hybrid: the first requirement should be "Availability to travel at own expense to work onsite ([in City, State] if available in the job description) per client’s request". 
          
        4. The sequence for requirements should be:
            a. Experience/Skills/Abilities with all required skills listed first along with their durations in brackets.
            b. then Experience/Skills/Abilities that are non-mandatory but preferred
            c. then the Certifications required. (only if mentioned in the job description. omit if nothing is there)
            d. then the Education required. (only if mentioned in the job description. omit if nothing is there)
        5. All Soft skills or generic skills should be excluded.
        7. Do not write a client's name anywhere in the requirements, instead replace it by writing 'client' or 'client's'. Refer below to the list of all client names that you must replace. Examples: FDOT, DEP
        8. If there's a requirement specific to the client, make it generalised. If after generalisation it does not add any value, remove it altogether. 
        Example: 
        Original - Experience with Saleforce development of the department's enterprise grants system
        Modified - Experience with Saleforce development of an enterprise grants system

        Original- Experience with FDOT architecture/environment
        Generalised - Experience with client's architecture/environment <- this does not add any value after generalisation, therefore omit this requirement altogether
        9. Any background check related requirement should be excluded
        10. Club similar requirements together to reduce the overall number of requirements to less than 15.
        11. All requirements must be numbered.



        List of client names and their variants:
        {client_names}



        The job description is provided between the delimiters.
        Job description:
        ```{jd_document}```
        """
    )
    

    candidate_skillset = candidate_skillset_p_template.format_messages(jd_document=jd_document, client_names=client_names)
    # print(candidate_skillset)
    part2_raw = chat(candidate_skillset)
    print("~~~~~~~~~🟪PART 2🟪~~~~~~~~~~~\n")
    print(part2_raw.content)
    print("\n~~~~~~~~~~~~~~~~~~~~~~~~~~")


    verification1_template = ChatPromptTemplate.from_template(
        """
        As a hiring manager, your objective is to refine, reanalyze, reorder and filter the Raw Job Requirements and only return the most important technical skills, certifications, and educational qualifications.
        Please strictly adhere to the following guidelines during extraction:

        1. Make sure that wherever the job description mentions a certain number of years of experience required, you also mention the same in brackets after that requirement like this: (3+ years)
        2. If a requirement does not mention any number of years of experience required, do not mention any default value as number of years.
        3. If the number of years are mentioned as a range with lower limit as 0 years, mention only the upper limit. Example: if the job description mentions the required experience duration as '0-2 years', please mention '2 years' in brackes.
        4. If the job description explicitly mentions any skills as good-to-have or preferred, please make sure that you have written 'preferred' in brackets after that requirement.
        5. Make sure there are no Responsibilities, Soft skills or generic requirements in this list.
        6. Make sure that client's name is not mentioned anywhere, instead use words like 'client' or 'client's'. Below is the list of all client names that you must check and replace. Examples: FDOT, DEP
        7. Make sure that any first person pronouns like us, we etc. are changed to client, client's
        9. Make sure there are no repeating requirements in the list, only unique requirements should be listed
        10. Remove all generic, non-technical, soft skill requirements from the list.
        11. Make sure that you've not added any requirement from your side. Only the requirements from the job description should be used.
        12. Club similar requirements together to reduce the overall number of requirements to less than 15.
        13. Retain only the most important requirements.


    14. Please reorder the list of requirements as follows:

            a. The location requirement (only if it is there in the Raw requirements) will come at the top. If nothing is there in the Raw requirements, omit this altogether.
            b. Experience/Skills with all required skills that have experience duration mentioned should be listed first.
            c. Experience/Skills with all required skills that do not have experience duration mentioned should be listed second.
            d. Experience/Skills with all prefered/good-to-have skills should be listed third.
            e. then Certifications. (only if mentioned in the job description. omit if nothing is there)
            f. then Education. (only if mentioned in the job description. omit if nothing is there)

        15. Example of a response =>
        Requirements:
        (1) First and foremost requirement related to the job (5+ years)
        (2) Another requirement
        (3) Another requirement (prefered)
        (4) Certification
        (5) Education (only if mentioned in the job description. omit if nothing is there)


        16. All requirements must be numbered by the new order you'll decide.

        ...

        List of client names and their variants:
        {client_names}

        The job Raw Requirements to confirm, re order, reformat or rephrase are provided between the delimiters:

        ```{first_extract}```


        """
    )
    part2_raw_filtered_template = verification1_template.format_messages(first_extract=part2_raw.content, client_names=client_names)

    part2_raw_filtered = chat(part2_raw_filtered_template)

    print(part2_raw_filtered.content)
    print("\n~~~~~~~~~~~~~~~~~~~~~~~~~~")


    ##########

    verification2_template = ChatPromptTemplate.from_template(
        """
        Please look at the requirements of a job below and process them as follows:

        1. Make sure a particular skill or experience requirement only gets mentioned once. Remove redundancies strictly.
        2. Absolutely remove any soft skills or generic and non-technical information which does not help a job candidate. The first point should remain about availability to work ion case of onsite and hybrid.
        3. Totally remove any client-specific requirement that does not have technical details
        4. Try to club similar requirements together to reduce the overall number of requirements to less than 15.
        5. Make sure all technical requirements are at the top, then preferred ones, then certifications, then education at the end.

        These are the only changes I need. Reproduce everything else as it is. Do not change the sequence of the original job requirements.
        

        Job Requirements are provided between the delimiters:

        ```{second_extract}```


        """
    )
    part2_raw_filtered2_template = verification2_template.format_messages(second_extract=part2_raw_filtered.content)

    part2_raw_filtered2 = chat(part2_raw_filtered2_template)

    print(part2_raw_filtered2.content)



    ##########










    verification4_part2_template = ChatPromptTemplate.from_template(
        """
        As a verification officer, your task is to ensure that the provided list of requirements adheres to the required JSON format.
        Your response should only include the JSON. If the format is incorrect, please modify it accordingly. The correct format should be like:

        (
            "Requirements": [
                "(1) First and foremost requirement related to the job.",
                "(2) Another requirement.",
                ...
            ]
        )

        The list of requirements will be provided between the delimiters:
        Requirements:
        ```{jd_document}```

        ----------------------------
        {format_instructions}
        ----------------------------
        Only respond with a valid JSON object, no other comments.
        """
    )
    part2_verification_part2 = verification4_part2_template.format_messages(jd_document=part2_raw_filtered2.content, format_instructions=format_instructions_part2)
    part2_raw_filtered3 = chat(part2_verification_part2)

    print(part2_raw_filtered3.content)
    print("\n~~~~~~~~~~~~~~~~~~~~~~~~~~")

    # SECTION 3

    responsibilities_details_p_template = ChatPromptTemplate.from_template(
        """
        As a hiring agency, your task is to carefully analyze the job description and distill the candidate's primary responsibilities. Adhere to the following guidelines during extraction:

        1. Focus on the candidate's core tasks, excluding any requirements or skills.
        2. Only the top 7 most vital responsibilities should be listed.
        3. Avoid generic or non-specific responsibilities.
        4. Make sure all the responsibilities are numbered or enumerated.

        After analyzing, the extracted responsibilities should follow this structure:

        Responsibilities:
        (1) First and foremost responsibility related to the job.
        (2) Another central task.
        ...
        (7) The seventh most important responsibility.

        The job description will be provided between the delimiters:
        Job description:
        ```{jd_document}```

        ----------------------------
        {format_instructions}
        ----------------------------
        return a valid JSON object
        """
    )
    responsibilities_details = responsibilities_details_p_template.format_messages(jd_document=jd_document, format_instructions=format_instructions_part3)
    part3_raw = chat(responsibilities_details)

    verification2_template = ChatPromptTemplate.from_template(
        """
        As a hiring manager, your task is to carefully analyze, filter and reorder candidate's primary responsibilities based on some Raw Data.

        1. Focus on the candidate's core tasks, excluding any requirements or skills.
        2. Keep only the clear responsibilities.
        3. Remove generic or non-specific responsibilities.
        4. Ensure each responsibility is enumerated and returned as an enumerated item on a list following the JSON template

        After analyzing, the extracted responsibilities should follow this structure:

        Responsibilities:
        (1) First and foremost responsibility related to the job.
        (2) Another central task.
        ...

        The Raw Data will be provided between the delimiters:
        Responsibilities:
        ```{jd_document}```

        ----------------------------
        {format_instructions}
        ----------------------------
        return a valid JSON object
        """
    )
    part3_raw_filtering = verification2_template.format_messages(jd_document=part3_raw.content, format_instructions=format_instructions_part3)
    part3_raw_filtered = chat(part3_raw_filtering)
    p3_verification3_template = ChatPromptTemplate.from_template(
        """
        As a verification officer, your task is to ensure the extracted responsibilities are generic and not client-specific. Adhere to the following guidelines during the review:

        1. If the client’s name or abbreviation of the name is mentioned, replace it with “client”.
        2. If pronouns such as we, us or our(s) are used, replace them with client(‘s).
        3. keep the Requirements in the same JSON format in the same order, and only modify a little their content to make them more compliant with the guidelines.

        For example:
        - Research and understand FDOT client’s business processes and their inter-relationships. => Research and understand client client’s business processes and their inter-relationships.

        The list of responsibilities will be provided between the delimiters:
        Responsibilities:
        ```{jd_document}```

        ----------------------------
        {format_instructions}
        ----------------------------
        return a valid JSON object
        """
    )
    part3_verification = p3_verification3_template.format_messages(jd_document=part3_raw_filtered.content, format_instructions=format_instructions_part3)
    part3_verified = chat(part3_verification)

    verification4_template = ChatPromptTemplate.from_template(
        """
        As a verification officer, your task is to ensure that the provided information adheres to the required JSON format.
        Your response should only include the JSON. If the format is incorrect, please modify it accordingly. The correct format should be like:

        (
            "Responsibilities": [
                "(1) First and foremost responsibility related to the job.",
                "(2) Another central task.",
                ...
            ]
        )

        The list of responsibilities will be provided between the delimiters:
        Responsibilities:
        ```{jd_document}```

        ----------------------------
        {format_instructions}
        ----------------------------
        Only respond with a valid JSON object, no other comments.
        """
    )
    part3_verification = verification4_template.format_messages(jd_document=part3_verified.content, format_instructions=format_instructions_part3)
    part3_verified = chat(part3_verification)

    part1 = output_parser_part1.parse(part1_raw_v2.content)
    # merge 2 dictionaries part1 + part1_defaults
    part1 = {**part1, **part1_defaults}

    part2 = output_parser_part2.parse(part2_raw_filtered3.content)

    part3 = output_parser_part3.parse(part3_verified.content)
    return create_docx_L1(formatted_title,part1, part2, part3, filename_output=filename_output)

# process_jd_l1("inputs/JD_Example_1.docx")